
Findings:

  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/integration-test/java/com/dotcms/rest/DummyResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

         14â”†     @POST
         15â”† 	@Path("/postauth")
         16â”† 	public String doPostAuthentication(@Context HttpServletRequest request, @FormParam("user") String user, @FormParam("password") String password) {
         17â”†         webResource.init("user/" + user + "/password/" + password, true, request, true, null);
         18â”†         return "success";
         19â”† 	}


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/integration-test/java/com/dotmarketing/portlets/contentlet/transform/ContentletTransformerTest.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.object-deserialization
        Found object deserialization using ObjectInputStream. Deserializing entire Java objects is
        dangerous because malicious actors can create Java object streams with unintended
        consequences. Ensure that the objects being deserialized are not user-controlled. If this
        must be done, consider using HMACs to sign the data stream to make sure it is not tampered
        with, or consider only transmitting object fields and populating a new object.

        861â”† try(ObjectInputStream inputStream = new ObjectInputStream(fileInputStream)){


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/integration-test/java/com/ettrema/httpclient/RespUtils.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.owasp.java.xxe.org.jdom2.input.SAXBuild
     er
        SAXBuilder being instantiated without calling the setFeature functions that are generally
        used for disabling entity processing

         97â”† SAXBuilder builder = new SAXBuilder();
          â‹®â”†----------------------------------------
         97â”† SAXBuilder builder = new SAXBuilder();
         98â”† builder.setExpandEntities(false);
         99â”† return builder.build(bin);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        298â”† @POST
        299â”† @Path("/logout/{idpConfigId}")
        300â”† @NoCache
        301â”† @Produces({MediaType.TEXT_HTML, MediaType.APPLICATION_XHTML_XML})
        302â”† // Login configuration by id
        303â”† public void logoutPost(@PathParam("idpConfigId") final String idpConfigId,
        304â”† 				   @Context final HttpServletRequest httpServletRequest,
        305â”† 				   @Context final HttpServletResponse httpServletResponse) throws IOException, URISyntaxException {
        306â”† 
        307â”† 	if (DotSamlProxyFactory.getInstance().isAnyHostConfiguredAsSAML()) {
           [hid 26 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/cache/lettuce/DotObjectCodec.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.object-deserialization
        Found object deserialization using ObjectInputStream. Deserializing entire Java objects is
        dangerous because malicious actors can create Java object streams with unintended
        consequences. Ensure that the objects being deserialized are not user-controlled. If this
        must be done, consider using HMACs to sign the data stream to make sure it is not tampered
        with, or consider only transmitting object fields and populating a new object.

         31â”† try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes.array()))){


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/dotpubsub/PostgresPubSubImpl.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.formatted-sql-string
        Detected a formatted string in a SQL statement. This could lead to SQL injection if
        variables in the SQL statement are not properly sanitized. Use a prepared statements
        (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using
        'connection.prepareStatement'.

        170â”† stmt.execute("LISTEN " + topic.toString().toLowerCase());
          â‹®â”†----------------------------------------
        177â”† stmt.execute("UNLISTEN " + topic.toString().toLowerCase());


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rendering/velocity/directive/DotParse.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.httpservlet-path-traversal
        Detected a potential path traversal. A malicious actor could control the location of this
        file, to include going backwards in the directory with '../'. To address this, ensure that
        user-controlled variables in file paths are sanitized. You may also consider using a utility
        method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file
        name from the path.

        141â”† final File fileToServe = contentlet.getBinary(idAndField._2);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/BundleResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        377â”† 	@DELETE
        378â”†     @Path("/ids")
        379â”†     @Produces("application/json")
        380â”†     public Response deleteBundlesByIdentifiers(@Context   final HttpServletRequest request,
        381â”†                                                @Context   final HttpServletResponse response,
        382â”†                                                final DeleteBundlesByIdentifierForm  deleteBundlesByIdentifierForm) {
        383â”† 
        384â”†         final InitDataObject initData = new WebResource.InitBuilder(webResource)
        385â”†                 .requiredBackendUser(true)
        386â”†                 .requiredFrontendUser(false)
           [hid 37 additional lines, adjust with --max-lines-per-finding] 
        516â”† @DELETE
        517â”† @Path("/olderthan/{olderThan}")
        518â”† @Produces("application/json")
        519â”† public Response deleteBundlesOlderThan(@Context   final HttpServletRequest request,
        520â”†                                    @Context   final HttpServletResponse response,
        521â”†                                    @PathParam("olderThan") final ISODateParam olderThan) {
        522â”† 
        523â”†     if(olderThan.after(new Date())) {
        524â”† 
        525â”†         throw new IllegalArgumentException("To avoid deleting bundles that publish in the future, the date can not be after the current date");
           [hid 37 additional lines, adjust with --max-lines-per-finding] 
        570â”† @DELETE
        571â”† @Path("/all")
        572â”† @Produces("application/json")
        573â”† public Response deleteAll(@Context   final HttpServletRequest request,
        574â”†                           @Context   final HttpServletResponse response) {
        575â”† 
        576â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
        577â”†             .requiredBackendUser(true)
        578â”†             .requiredFrontendUser(false)
        579â”†             .requestAndResponse(request, response)
           [hid 30 additional lines, adjust with --max-lines-per-finding] 
        617â”† @DELETE
        618â”† @Path("/all/fail")
        619â”† @Produces("application/json")
        620â”† public Response deleteAllFail(@Context   final HttpServletRequest request,
        621â”†                           @Context   final HttpServletResponse response) {
        622â”† 
        623â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
        624â”†             .requiredBackendUser(true)
        625â”†             .requiredFrontendUser(false)
        626â”†             .requestAndResponse(request, response)
           [hid 30 additional lines, adjust with --max-lines-per-finding] 
        677â”† @DELETE
        678â”† @Path("/all/success")
        679â”† @Produces("application/json")
        680â”† public Response deleteAllSuccess(@Context final HttpServletRequest request,
        681â”†                                   @Context final HttpServletResponse response) {
        682â”† 
        683â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
        684â”†             .requiredBackendUser(true)
        685â”†             .requiredFrontendUser(false)
        686â”†             .requestAndResponse(request, response)
           [hid 29 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/ClusterResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        158â”† @POST
        159â”† @Path("/remove/{params:.*}")
        160â”† public Response removeFromCluster(@Context HttpServletRequest request, @Context final HttpServletResponse response, @PathParam("params") String params) {
        161â”†     InitDataObject initData = webResource.init(params, request, response, true, PortletID.CONFIGURATION.toString());
        162â”†     String serverId = initData.getParamsMap().get("serverid");
        163â”†     try {
        164â”†     	HibernateUtil.startTransaction();
        165â”†         APILocator.getServerAPI().removeServerFromClusterTable(serverId);
        166â”†         HibernateUtil.closeAndCommitTransaction();
        167â”†     }
           [hid 14 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/ContentResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        153â”† @POST
        154â”† @Path("/_search")
        155â”† @Produces(MediaType.APPLICATION_JSON)
        156â”† public Response search(@Context HttpServletRequest request,
        157â”†                        @Context final HttpServletResponse response,
        158â”†                        final SearchForm searchForm) throws DotSecurityException, DotDataException {
        159â”† 
        160â”†     final InitDataObject initData = this.webResource.init
        161â”†             (null, request, response, false, null);
        162â”† 
           [hid 60 additional lines, adjust with --max-lines-per-finding] 
        308â”† @PUT
        309â”† @Path("/lock/{params:.*}")
        310â”† @Produces(MediaType.APPLICATION_JSON)
        311â”† 
        312â”† public Response lockContent(@Context HttpServletRequest request,
        313â”†         @Context HttpServletResponse response, @PathParam("params") String params)
        314â”†         throws DotDataException, JSONException {
        315â”† 
        316â”†     InitDataObject initData = webResource.init(params, request, response, false, null);
        317â”†     Map<String, String> paramsMap = initData.getParamsMap();
           [hid 60 additional lines, adjust with --max-lines-per-finding] 
        380â”† @PUT
        381â”† @Path("/canLock/{params:.*}")
        382â”† @Produces(MediaType.APPLICATION_JSON)
        383â”† public Response canLockContent(@Context HttpServletRequest request, @Context final HttpServletResponse response,
        384â”†         @PathParam("params") String params)
        385â”†         throws DotDataException, JSONException {
        386â”† 
        387â”†     InitDataObject initData = webResource.init(params, request, response, false, null);
        388â”†     Map<String, String> paramsMap = initData.getParamsMap();
        389â”†     String callback = paramsMap.get(RESTParams.CALLBACK.getValue());
           [hid 77 additional lines, adjust with --max-lines-per-finding] 
        468â”† @PUT
        469â”† @Path("/unlock/{params:.*}")
        470â”† @Produces(MediaType.APPLICATION_JSON)
        471â”† 
        472â”† public Response unlockContent(@Context HttpServletRequest request,
        473â”†         @Context HttpServletResponse response, @PathParam("params") String params)
        474â”†         throws DotDataException, JSONException {
        475â”† 
        476â”†     InitDataObject initData = webResource.init(params, request, response, false, null);
        477â”† 
           [hid 58 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        172â”† @POST
        173â”† @Path("/_generateintegritydata")
        174â”† @Produces("text/plain")
        175â”† public Response generateIntegrityData(@Context HttpServletRequest request)  {
        176â”† 
        177â”†     if (LicenseManager.getInstance().isCommunity()) {
        178â”†         throw new InvalidLicenseException("License required");
        179â”†     }
        180â”† 
        181â”†     final String localAddress = RestEndPointIPUtil.getFullLocalIp(request);
           [hid 52 additional lines, adjust with --max-lines-per-finding] 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.httpservlet-path-traversal
        Detected a potential path traversal. A malicious actor could control the location of this
        file, to include going backwards in the directory with '../'. To address this, ensure that
        user-controlled variables in file paths are sanitized. You may also consider using a utility
        method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file
        name from the path.

        907â”† final File bundle = new File(IntegrityUtil.getIntegrityDataFilePath(
        908â”†         endpointId,
        909â”†         IntegrityUtil.INTEGRITY_DATA_TO_FIX_ZIP_FILENAME));


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/JSPPortlet.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

         44â”† @POST
         45â”† @Path("/{params:.*}")
         46â”† @Produces("text/html")
         47â”† public Response layoutPost(@Context HttpServletRequest request, @Context HttpServletResponse response, @PathParam("params") String params) throws DotDataExcepti ... [0m
         48â”† 		DotSecurityException, ServletException, IOException, DotRuntimeException, PortalException, SystemException {
         49â”† 
         50â”† 	return super.getLayout(request, response, params);
         51â”† }
          [shortened a long line from output, adjust with --max-chars-per-line]


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/LicenseResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        163â”† @NoCache
        164â”† @DELETE
        165â”† @Path("/delete/{params:.*}")
        166â”† public Response delete(@Context HttpServletRequest request, @Context final HttpServletResponse response, @PathParam("params") String params) {
        167â”† 
        168â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
        169â”†             .requiredBackendUser(true)
        170â”†             .requiredFrontendUser(false)
        171â”†             .params(params)
        172â”†             .requestAndResponse(request, response)
           [hid 28 additional lines, adjust with --max-lines-per-finding] 
        202â”† @NoCache
        203â”† @POST
        204â”† @Path("/pick/{params:.*}")
        205â”† public Response pickLicense(@Context HttpServletRequest request, @Context final HttpServletResponse response, @PathParam("params") String params) {
        206â”† 
        207â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
        208â”†             .requiredBackendUser(true)
        209â”†             .requiredFrontendUser(false)
        210â”†             .params(params)
        211â”†             .requestAndResponse(request, response)
           [hid 40 additional lines, adjust with --max-lines-per-finding] 
        253â”† @NoCache
        254â”† @POST
        255â”† @Path("/free/{params:.*}")
        256â”† public Response freeLicense(@Context HttpServletRequest request, @Context final HttpServletResponse response, @PathParam("params") String params) {
        257â”† 
        258â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
        259â”†             .requiredBackendUser(true)
        260â”†             .requiredFrontendUser(false)
        261â”†             .params(params)
        262â”†             .requestAndResponse(request, response)
           [hid 88 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/TagResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        329â”† @DELETE
        330â”† @JSONP
        331â”† @Path("/{tagId}")
        332â”† @NoCache
        333â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        334â”† public Response delete(@Context final HttpServletRequest request,
        335â”†         @Context final HttpServletResponse response,
        336â”†         @PathParam("tagId") final String tagId) {
        337â”† 
        338â”†     final InitDataObject initDataObject =
           [hid 31 additional lines, adjust with --max-lines-per-finding] 
        382â”† @PUT
        383â”† @JSONP
        384â”† @Path("/tag/{nameOrId}/inode/{inode}")
        385â”† @NoCache
        386â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        387â”† public Response linkTagsAndInode(@Context final HttpServletRequest request,
        388â”†         @Context final HttpServletResponse response,
        389â”†         @PathParam("nameOrId") final String nameOrId,
        390â”†         @PathParam("inode") final String inode) {
        391â”† 
           [hid 39 additional lines, adjust with --max-lines-per-finding] 
        474â”† @DELETE
        475â”† @JSONP
        476â”† @Path("/inode/{inode}")
        477â”† @NoCache
        478â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        479â”† public Response deleteTagInodesByInode(@Context final HttpServletRequest request,
        480â”†         @Context final HttpServletResponse response,
        481â”†         @PathParam("inode") final String inode) {
        482â”† 
        483â”†     final InitDataObject initDataObject =
           [hid 29 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/apps/AppsResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        238â”† @POST
        239â”† @Path("/{key}/{siteId}")
        240â”† @JSONP
        241â”† @NoCache
        242â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        243â”† public final Response createAppSecrets(
        244â”†         @Context final HttpServletRequest request,
        245â”†         @Context final HttpServletResponse response,
        246â”†         @PathParam("key") final String key,
        247â”†         @PathParam("siteId") final String siteId,
           [hid 22 additional lines, adjust with --max-lines-per-finding] 
        280â”† @PUT
        281â”† @Path("/{key}/{siteId}")
        282â”† @JSONP
        283â”† @NoCache
        284â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        285â”† public final Response updateAppIndividualSecret(
        286â”†         @Context final HttpServletRequest request,
        287â”†         @Context final HttpServletResponse response,
        288â”†         @PathParam("key") final String key,
        289â”†         @PathParam("siteId") final String siteId,
           [hid 22 additional lines, adjust with --max-lines-per-finding] 
        322â”† @DELETE
        323â”† @Path("/")
        324â”† @JSONP
        325â”† @NoCache
        326â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        327â”† public final Response deleteIndividualAppSecret(
        328â”†         @Context final HttpServletRequest request,
        329â”†         @Context final HttpServletResponse response,
        330â”†         final DeleteSecretForm secretForm
        331â”† ) {
           [hid 20 additional lines, adjust with --max-lines-per-finding] 
        365â”† @DELETE
        366â”† @Path("/{key}/{siteId}")
        367â”† @JSONP
        368â”† @NoCache
        369â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        370â”† public final Response deleteAllAppSecrets(
        371â”†         @Context final HttpServletRequest request,
        372â”†         @Context final HttpServletResponse response,
        373â”†         @PathParam("key") final String key,
        374â”†         @PathParam("siteId") final String siteId
           [hid 21 additional lines, adjust with --max-lines-per-finding] 
        407â”† @DELETE
        408â”† @Path("/{key}")
        409â”† @JSONP
        410â”† @NoCache
        411â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        412â”† public final Response deleteApp(
        413â”†         @Context final HttpServletRequest request,
        414â”†         @Context final HttpServletResponse response,
        415â”†         @PathParam("key") final String serviceKey,
        416â”†         @QueryParam("removeDescriptor") final boolean removeDescriptor
           [hid 18 additional lines, adjust with --max-lines-per-finding] 
        443â”† @POST
        444â”† @Path("/export")
        445â”† @JSONP
        446â”† @NoCache
        447â”† @Produces({MediaType.APPLICATION_OCTET_STREAM, MediaType.APPLICATION_JSON})
        448â”† public final Response exportSecrets(
        449â”†         @Context final HttpServletRequest request,
        450â”†         @Context final HttpServletResponse response,
        451â”†         final ExportSecretForm exportSecretForm
        452â”† ) {
           [hid 20 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/authentication/ApiTokenResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

         91â”† @PUT
         92â”† @Path("/{tokenId}/revoke")
         93â”† @JSONP
         94â”† @NoCache
         95â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
         96â”† public final Response revokeApiToken(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
         97â”†         @PathParam("tokenId") final String tokenId) {
         98â”† 
         99â”†     final InitDataObject initDataObject = this.webResource.init(null, true, request, true, "users");
        100â”†     final User user                     = initDataObject.getUser();
           [hid 19 additional lines, adjust with --max-lines-per-finding] 
        121â”† @DELETE
        122â”† @Path("/{tokenId}")
        123â”† @JSONP
        124â”† @NoCache
        125â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        126â”† public final Response deleteApiToken(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
        127â”†         @PathParam("tokenId") final String tokenId) {
        128â”† 
        129â”†     final InitDataObject initDataObject = this.webResource.init(null, true, request, true, "users");
        130â”†     final User user                     = initDataObject.getUser();
           [hid 17 additional lines, adjust with --max-lines-per-finding] 
        356â”† @PUT
        357â”† @Path("/users/{userid}/revoke")
        358â”† @JSONP
        359â”† @NoCache
        360â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        361â”† public final Response revokeUserToken(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
        362â”†                                      @PathParam("userid") final String userid) throws DotSecurityException, DotDataException {
        363â”† 
        364â”†     final InitDataObject initDataObject = new WebResource.InitBuilder(this.webResource).rejectWhenNoUser(true)
        365â”†                                             .requestAndResponse(request, response).requiredPortlet("users")
           [hid 26 additional lines, adjust with --max-lines-per-finding] 
        393â”† @PUT
        394â”† @Path("/users/revoke")
        395â”† @JSONP
        396â”† @NoCache
        397â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        398â”† public final Response revokeUsersToken(@Context final HttpServletRequest request,
        399â”†                                        @Context final HttpServletResponse response) throws DotSecurityException, DotDataException {
        400â”† 
        401â”†     final InitDataObject initDataObject = new WebResource.InitBuilder(this.webResource).rejectWhenNoUser(true)
        402â”†             .requestAndResponse(request, response).requiredPortlet("users")
           [hid 27 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/authentication/CreateJsonWebTokenResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

         90â”† @POST
         91â”† @Path("/api-token")
         92â”† @JSONP
         93â”† @NoCache
         94â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
         95â”† public final Response getApiToken(@Context final HttpServletRequest request,
         96â”†                                      @Context final HttpServletResponse response,
         97â”†                                      final CreateTokenForm createTokenForm) {
         98â”† 
         99â”†     final String userId = createTokenForm.user;
           [hid 72 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/browser/BrowserResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

         96â”† @Path("/selectedfolder")
         97â”† @PUT
         98â”† @JSONP
         99â”† @NoCache
        100â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        101â”† public Response selectFolder(@Context final HttpServletRequest request,
        102â”†                                  @Context final HttpServletResponse response,
        103â”†                                  final OpenFolderForm openFolderForm) throws DotSecurityException, DotDataException {
        104â”† 
        105â”†     final InitDataObject initData = new WebResource.InitBuilder()
           [hid 15 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/categories/CategoriesResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        424â”† @PUT
        425â”† @Path("/_sort")
        426â”† @JSONP
        427â”† @NoCache
        428â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        429â”† public final Response save(@Context final HttpServletRequest httpRequest,
        430â”†         @Context final HttpServletResponse httpResponse,
        431â”†         final CategoryEditForm categoryEditForm
        432â”† ) throws DotDataException, DotSecurityException {
        433â”† 
           [hid 31 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/container/ContainerResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        586â”† @Path("/containerContent/{params:.*}")
        587â”† public final Response containerContents(@Context final HttpServletRequest req, @Context final HttpServletResponse res,
        588â”†         @QueryParam("containerId") final String containerId, @QueryParam("contentInode") final String contentInode)
        589â”†         throws DotDataException, IOException {
        590â”† 
        591â”†     final InitDataObject initData = webResource.init(req, res, true);
        592â”†     final User user = initData.getUser();
        593â”† 
        594â”†     try {
        595â”† 
           [hid 36 additional lines, adjust with --max-lines-per-finding] 
        874â”† @PUT
        875â”† @Path("/_publish")
        876â”† @JSONP
        877â”† @NoCache
        878â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        879â”† public final Response publish(@Context final HttpServletRequest  request,
        880â”†                                 @Context final HttpServletResponse response,
        881â”†                                 @QueryParam("containerId") final String containerId) throws DotSecurityException, DotDataException {
        882â”† 
        883â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 30 additional lines, adjust with --max-lines-per-finding] 
        929â”† @PUT
        930â”† @Path("/_unpublish")
        931â”† @JSONP
        932â”† @NoCache
        933â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        934â”† public final Response unpublish(@Context final HttpServletRequest  request,
        935â”†                               @Context final HttpServletResponse response,
        936â”†                               @QueryParam("containerId") final String containerId) throws DotSecurityException, DotDataException {
        937â”† 
        938â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 29 additional lines, adjust with --max-lines-per-finding] 
        982â”† @PUT
        983â”† @Path("/_archive")
        984â”† @JSONP
        985â”† @NoCache
        986â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        987â”† public final Response archive(@Context final HttpServletRequest  request,
        988â”†                               @Context final HttpServletResponse response,
        989â”†                               @QueryParam("containerId") final String containerId) throws DotSecurityException, DotDataException {
        990â”† 
        991â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 29 additional lines, adjust with --max-lines-per-finding] 
       1035â”† @PUT
       1036â”† @Path("/_unarchive")
       1037â”† @JSONP
       1038â”† @NoCache
       1039â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1040â”† public final Response unarchive(@Context final HttpServletRequest  request,
       1041â”†                               @Context final HttpServletResponse response,
       1042â”†                               @QueryParam("containerId") final String containerId) throws DotSecurityException, DotDataException {
       1043â”† 
       1044â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 29 additional lines, adjust with --max-lines-per-finding] 
       1142â”† @POST
       1143â”† @Path("/{id}/_copy")
       1144â”† @JSONP
       1145â”† @NoCache
       1146â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1147â”† public ResponseEntityContainerView copy(@Context final HttpServletRequest request,
       1148â”†         @Context final HttpServletResponse response,
       1149â”†         @PathParam("id") final String id) throws DotDataException, DotSecurityException {
       1150â”† 
       1151â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 32 additional lines, adjust with --max-lines-per-finding] 
       1197â”† @DELETE
       1198â”† @Path("_bulkdelete")
       1199â”† @JSONP
       1200â”† @NoCache
       1201â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1202â”† public final Response bulkDelete(@Context final HttpServletRequest  request,
       1203â”†         @Context final HttpServletResponse response,
       1204â”†         final List<String> containersToDelete) {
       1205â”† 
       1206â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 38 additional lines, adjust with --max-lines-per-finding] 
       1260â”† @PUT
       1261â”† @Path("/_bulkpublish")
       1262â”† @JSONP
       1263â”† @NoCache
       1264â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1265â”† public final Response bulkPublish(@Context final HttpServletRequest  request,
       1266â”†         @Context final HttpServletResponse response,
       1267â”†         final List<String> containersToPublish){
       1268â”† 
       1269â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 37 additional lines, adjust with --max-lines-per-finding] 
       1321â”† @PUT
       1322â”† @Path("/_bulkunpublish")
       1323â”† @JSONP
       1324â”† @NoCache
       1325â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1326â”† public final Response bulkUnpublish(@Context final HttpServletRequest  request,
       1327â”†         @Context final HttpServletResponse response,
       1328â”†         final List<String> containersToUnpublish) {
       1329â”† 
       1330â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 37 additional lines, adjust with --max-lines-per-finding] 
       1382â”† @PUT
       1383â”† @Path("/_bulkarchive")
       1384â”† @JSONP
       1385â”† @NoCache
       1386â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1387â”† public final Response bulkArchive(@Context final HttpServletRequest  request,
       1388â”†         @Context final HttpServletResponse response,
       1389â”†         final List<String> containersToArchive) {
       1390â”† 
       1391â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 38 additional lines, adjust with --max-lines-per-finding] 
       1445â”† @PUT
       1446â”† @Path("/_bulkunarchive")
       1447â”† @JSONP
       1448â”† @NoCache
       1449â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1450â”† public final Response bulkUnarchive(@Context final HttpServletRequest  request,
       1451â”†         @Context final HttpServletResponse response,
       1452â”†         final List<String> containersToUnarchive){
       1453â”† 
       1454â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 37 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/content/ContentResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        250â”† @POST
        251â”† @JSONP
        252â”† @NoCache
        253â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        254â”† @Path("related")
        255â”† @Operation(summary = "Pull Related Content",
        256â”†         responses = {
        257â”†                 @ApiResponse(
        258â”†                         responseCode = "200",
        259â”†                         content = @Content(mediaType = "application/json",
           [hid 52 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/contenttype/ContentTypeResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        506â”† @DELETE
        507â”† @Path("/id/{idOrVar}")
        508â”† @JSONP
        509â”† @NoCache
        510â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        511â”† public Response deleteType(@PathParam("idOrVar") final String idOrVar, @Context final HttpServletRequest req, @Context final HttpServletResponse res)
        512â”† 		throws DotDataException, JSONException {
        513â”† 
        514â”† 	final InitDataObject initData = this.webResource.init(null, req, res, true, null);
        515â”† 	final User user = initData.getUser();
           [hid 26 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/contenttype/FieldResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        396â”† @DELETE
        397â”† @Path("/id/{fieldId}")
        398â”† @JSONP
        399â”† @NoCache
        400â”† @Produces({ MediaType.APPLICATION_JSON, "application/javascript" })
        401â”† public Response deleteContentTypeFieldById(@PathParam("typeId") final String typeId,
        402â”† 										   @PathParam("fieldId") final String fieldId, @Context final HttpServletRequest req)
        403â”† 		throws DotDataException, DotSecurityException {
        404â”† 
        405â”† 	final InitDataObject initData = this.webResource.init(null, false, req, false, null);
           [hid 25 additional lines, adjust with --max-lines-per-finding] 
        432â”† @DELETE
        433â”† @Path("/var/{fieldVar}")
        434â”† @JSONP
        435â”† @NoCache
        436â”† @Produces({ MediaType.APPLICATION_JSON, "application/javascript" })
        437â”† public Response deleteContentTypeFieldByVar(@PathParam("typeId") final String typeId,
        438â”† 		@PathParam("fieldVar") final String fieldVar, @Context final HttpServletRequest req)
        439â”† 		throws DotDataException, DotSecurityException {
        440â”† 
        441â”† 	final InitDataObject initData = this.webResource.init(null, false, req, false, null);
           [hid 26 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/contenttype/FieldVariableResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        441â”† @DELETE
        442â”† @Path("/id/{fieldId}/variables/id/{fieldVarId}")
        443â”† @JSONP
        444â”† @NoCache
        445â”† @Produces({ MediaType.APPLICATION_JSON, "application/javascript" })
        446â”† public Response deleteFieldVariableByFieldId(@PathParam("typeId") final String typeId,
        447â”† 		@PathParam("fieldId") final String fieldId, @PathParam("fieldVarId") final String fieldVarId,
        448â”† 		@Context final HttpServletRequest req, @Context final HttpServletResponse res) throws DotDataException {
        449â”† 
        450â”† 	this.webResource.init(null, req, res, false, null);
           [hid 31 additional lines, adjust with --max-lines-per-finding] 
        483â”† @DELETE
        484â”† @Path("/var/{fieldVar}/variables/id/{fieldVarId}")
        485â”† @JSONP
        486â”† @NoCache
        487â”† @Produces({ MediaType.APPLICATION_JSON, "application/javascript" })
        488â”† public Response deleteFieldVariableByFieldVar(@PathParam("typeId") final String typeId,
        489â”† 		@PathParam("fieldVar") final String fieldVar, @PathParam("fieldVarId") final String fieldVarId,
        490â”† 		@Context final HttpServletRequest req, @Context final HttpServletResponse res) throws DotDataException {
        491â”† 
        492â”† 	this.webResource.init(null, req, res, false, null);
           [hid 31 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/experiments/ExperimentsResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        114â”† @PATCH
        115â”† @Path("/{experimentId}")
        116â”† @JSONP
        117â”† @NoCache
        118â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        119â”† public ResponseEntitySingleExperimentView update(@Context final HttpServletRequest request,
        120â”†         @Context final HttpServletResponse response,
        121â”†         @PathParam("experimentId") final String experimentId,
        122â”†         final ExperimentForm experimentForm) throws DotDataException, DotSecurityException {
        123â”†     final InitDataObject initData = getInitData(request, response);
           [hid 13 additional lines, adjust with --max-lines-per-finding] 
        144â”† @PUT
        145â”† @Path("/{experimentId}/_archive")
        146â”† @JSONP
        147â”† @NoCache
        148â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        149â”† public ResponseEntityExperimentView archive(@Context final HttpServletRequest request,
        150â”†         @Context final HttpServletResponse response,
        151â”†         @PathParam("experimentId") final String experimentId) throws DotDataException, DotSecurityException {
        152â”†     final InitDataObject initData = getInitData(request, response);
        153â”†     final User user = initData.getUser();
           [hid 3 additional lines, adjust with --max-lines-per-finding] 
        162â”† @DELETE
        163â”† @Path("/{experimentId}")
        164â”† @JSONP
        165â”† @NoCache
        166â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        167â”† public ResponseEntityView<String> delete(@Context final HttpServletRequest request,
        168â”†         @Context final HttpServletResponse response,
        169â”†         @PathParam("experimentId") final String experimentId) throws DotDataException, DotSecurityException {
        170â”†     final InitDataObject initData = getInitData(request, response);
        171â”†     final User user = initData.getUser();
           [hid 3 additional lines, adjust with --max-lines-per-finding] 
        229â”† @DELETE
        230â”† @Path("/{experimentId}/goals/primary")
        231â”† @JSONP
        232â”† @NoCache
        233â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        234â”† public ResponseEntitySingleExperimentView deleteGoal(@Context final HttpServletRequest request,
        235â”†         @Context final HttpServletResponse response,
        236â”†         @PathParam("experimentId") final String experimentId) throws DotDataException, DotSecurityException {
        237â”†     final InitDataObject initData = getInitData(request, response);
        238â”†     final User user = initData.getUser();
           [hid 11 additional lines, adjust with --max-lines-per-finding] 
        267â”† @POST
        268â”† @Path("/{experimentId}/_start")
        269â”† @JSONP
        270â”† @NoCache
        271â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        272â”† public ResponseEntitySingleExperimentView start(@Context final HttpServletRequest request,
        273â”†         @Context final HttpServletResponse response,
        274â”†         @PathParam("experimentId") final String experimentId) throws DotDataException, DotSecurityException {
        275â”†     final InitDataObject initData = getInitData(request, response);
        276â”†     final User user = initData.getUser();
           [hid 3 additional lines, adjust with --max-lines-per-finding] 
        286â”† @POST
        287â”† @Path("/{experimentId}/_end")
        288â”† @JSONP
        289â”† @NoCache
        290â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        291â”† public ResponseEntitySingleExperimentView end(@Context final HttpServletRequest request,
        292â”†         @Context final HttpServletResponse response,
        293â”†         @PathParam("experimentId") final String experimentId) throws DotDataException, DotSecurityException {
        294â”†     final InitDataObject initData = getInitData(request, response);
        295â”†     final User user = initData.getUser();
           [hid 3 additional lines, adjust with --max-lines-per-finding] 
        329â”† @DELETE
        330â”† @Path("/{experimentId}/variants/{name}")
        331â”† @JSONP
        332â”† @NoCache
        333â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        334â”† public ResponseEntitySingleExperimentView deleteVariant(@Context final HttpServletRequest request,
        335â”†         @Context final HttpServletResponse response,
        336â”†         @PathParam("experimentId") final String experimentId,
        337â”†         @PathParam("name") final String variantName) throws DotDataException, DotSecurityException {
        338â”†     final InitDataObject initData = getInitData(request, response);
           [hid 4 additional lines, adjust with --max-lines-per-finding] 
        380â”† @DELETE
        381â”† @Path("/{experimentId}/targetingConditions/{id}")
        382â”† @JSONP
        383â”† @NoCache
        384â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        385â”† public ResponseEntitySingleExperimentView deleteTargetingCondition(@Context final HttpServletRequest request,
        386â”†         @Context final HttpServletResponse response,
        387â”†         @PathParam("experimentId") final String experimentId,
        388â”†         @PathParam("id") final String conditionId) throws DotDataException, DotSecurityException {
        389â”†     final InitDataObject initData = getInitData(request, response);
           [hid 5 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/folder/FolderResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        152â”† @PUT
        153â”† @Path("/{id}/file-browser-selected")
        154â”† @NoCache
        155â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        156â”† public final Response selectFolder(@Context final HttpServletRequest httpServletRequest,
        157â”†         @Context final HttpServletResponse httpServletResponse,
        158â”†         @PathParam("id") final String folderId)
        159â”†         throws DotSecurityException, DotDataException {
        160â”† 
        161â”†     new WebResource.InitBuilder(webResource)
           [hid 9 additional lines, adjust with --max-lines-per-finding] 
        281â”† @POST
        282â”† @Path ("/byPath")
        283â”† @JSONP
        284â”† @NoCache
        285â”† @Produces({MediaType.APPLICATION_JSON})
        286â”† public final Response findSubFoldersByPath(@Context final HttpServletRequest httpServletRequest,
        287â”†         @Context final HttpServletResponse httpServletResponse,
        288â”†         final SearchByPathForm searchByPathForm
        289â”†         ) throws  DotDataException, DotSecurityException   {
        290â”† 
           [hid 38 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/index/ESIndexResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        212â”† @CloseDBIfOpened
        213â”† @DELETE
        214â”† @JSONP
        215â”† @NoCache
        216â”† @Path("/failed")
        217â”† @Produces({MediaType.APPLICATION_JSON})
        218â”† public Response deleteFailedRecords(@Context final HttpServletRequest request, @Context final HttpServletResponse response)
        219â”†                 throws DotDataException {
        220â”†     final InitDataObject init = auth(request, response);
        221â”†     APILocator.getReindexQueueAPI().deleteFailedRecords();
           [hid 2 additional lines, adjust with --max-lines-per-finding] 
        225â”† @CloseDBIfOpened
        226â”† @POST
        227â”† @JSONP
        228â”† @NoCache
        229â”† @Path("/optimize")
        230â”† @Produces({MediaType.APPLICATION_JSON})
        231â”† public Response optimizeIndices(@Context final HttpServletRequest request, @Context final HttpServletResponse response) {
        232â”†     final InitDataObject init = auth(request, response);
        233â”†     final ContentletIndexAPI api = APILocator.getContentletIndexAPI();
        234â”†     final List<String> indices = api.listDotCMSIndices();
           [hid 5 additional lines, adjust with --max-lines-per-finding] 
        241â”† @CloseDBIfOpened
        242â”† @DELETE
        243â”† @JSONP
        244â”† @NoCache
        245â”† @Path("/cache")
        246â”† @Produces({MediaType.APPLICATION_JSON})
        247â”† public Response flushIndiciesCache(@Context final HttpServletRequest request, @Context final HttpServletResponse response) {
        248â”†     final InitDataObject init = auth(request, response);
        249â”†     final ContentletIndexAPI api = APILocator.getContentletIndexAPI();
        250â”†     final List<String> indices = api.listDotCMSIndices();
           [hid 8 additional lines, adjust with --max-lines-per-finding] 
        261â”† @Deprecated
        262â”† @PUT
        263â”† @Path("/create/{params:.*}")
        264â”† @Produces("text/plain")
        265â”† public Response createIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam("params") String  ... [0m
        266â”†     try {
        267â”†         InitDataObject init=auth(httpServletRequest, httpServletResponse);
        268â”† 
        269â”†         int shards=Integer.parseInt(init.getParamsMap().get("shards"));
        270â”†         boolean live = init.getParamsMap().containsKey("live") ? Boolean.parseBoolean(init.getParamsMap().get("live")) : false;
          [shortened a long line from output, adjust with --max-chars-per-line]
           [hid 15 additional lines, adjust with --max-lines-per-finding] 
        294â”† @Deprecated
        295â”† @PUT
        296â”† @Path("/clear/{params:.*}")
        297â”† public Response clearIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam("params") String p ... [0m
        298â”† 
        299â”†     InitDataObject init=auth(httpServletRequest,httpServletResponse);
        300â”†     String indexName = this.indexHelper.getIndexNameOrAlias(init.getParamsMap(),"index","alias",this.indexAPI);
        301â”†     return modIndex(httpServletRequest, httpServletResponse, indexName, IndexAction.CLEAR.name());
        302â”† }
          [shortened a long line from output, adjust with --max-chars-per-line]
          â‹®â”†----------------------------------------
        321â”† @CloseDBIfOpened
        322â”† @POST
        323â”† @JSONP
        324â”† @NoCache
        325â”† @Path("/reindex")
        326â”† @Produces({MediaType.APPLICATION_JSON})
        327â”† public Response startReindex(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
        328â”†                 @QueryParam("shards") int shards, @DefaultValue(DOTALL) @QueryParam("contentType") String contentType) throws DotDataException, DotSecurityExcep ... [0m
        329â”†     final InitDataObject init = auth(request, response);
        330â”†     shards = (shards <= 0) ? Config.getIntProperty("es.index.number_of_shards", 2) : shards;
          [shortened a long line from output, adjust with --max-chars-per-line]
           [hid 18 additional lines, adjust with --max-lines-per-finding] 
        350â”† @CloseDBIfOpened
        351â”† @DELETE
        352â”† @JSONP
        353â”† @NoCache
        354â”† @Path("/reindex")
        355â”† @Produces({MediaType.APPLICATION_JSON})
        356â”† public Response stopReindexation(@Context final HttpServletRequest request,
        357â”†                 @Context final HttpServletResponse response,
        358â”†                 @DefaultValue("true") @QueryParam("switch") boolean switchMe)
        359â”†                 throws DotDataException {
           [hid 11 additional lines, adjust with --max-lines-per-finding] 
        373â”† @CloseDBIfOpened
        374â”† @DELETE
        375â”† @JSONP
        376â”† @NoCache
        377â”† @Path("/{indexName: .*}")
        378â”† @Produces({MediaType.APPLICATION_JSON})
        379â”† public Response deleteIndex(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
        380â”†                 @PathParam("indexName") final String indexName) throws DotDataException {
        381â”† 
        382â”†     final InitDataObject init = auth(request, response);
           [hid 15 additional lines, adjust with --max-lines-per-finding] 
        405â”† @Deprecated
        406â”† @PUT
        407â”† @Path("/activate/{params:.*}")
        408â”† public Response activateIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam("params") Strin ... [0m
        409â”†     InitDataObject init=auth(httpServletRequest,httpServletResponse);
        410â”†     String indexName = this.indexHelper.getIndexNameOrAlias(init.getParamsMap(),"index","alias",this.indexAPI);
        411â”†     return modIndex(httpServletRequest, httpServletResponse, indexName, IndexAction.ACTIVATE.name());
        412â”† }
          [shortened a long line from output, adjust with --max-chars-per-line]
          â‹®â”†----------------------------------------
        422â”† @Deprecated
        423â”† @PUT
        424â”† @Path("/deactivate/{params:.*}")
        425â”† public Response deactivateIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam("params") Str ... [0m
        426â”†     InitDataObject init=auth(httpServletRequest,httpServletResponse);
        427â”†     String indexName = this.indexHelper.getIndexNameOrAlias(init.getParamsMap(),"index","alias",this.indexAPI);
        428â”†     return modIndex(httpServletRequest, httpServletResponse, indexName, IndexAction.DEACTIVATE.name());
        429â”† }
          [shortened a long line from output, adjust with --max-chars-per-line]
          â‹®â”†----------------------------------------
        438â”† @Deprecated
        439â”† @PUT
        440â”† @Path("/close/{params:.*}")
        441â”† public Response closeIndex(@Context HttpServletRequest httpServletRequest,@Context final HttpServletResponse httpServletResponse, @PathParam("params") String pa ... [0m
        442â”†     InitDataObject init=auth(httpServletRequest,httpServletResponse);
        443â”†     String indexName = this.indexHelper.getIndexNameOrAlias(init.getParamsMap(),"index","alias",this.indexAPI);
        444â”†     return modIndex(httpServletRequest, httpServletResponse, indexName, IndexAction.CLOSE.name());
        445â”† }
          [shortened a long line from output, adjust with --max-chars-per-line]
          â‹®â”†----------------------------------------
        454â”† @Deprecated
        455â”† @PUT
        456â”† @Path("/open/{params:.*}")
        457â”† public Response openIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam("params") String pa ... [0m
        458â”†     try {
        459â”†         InitDataObject init=auth(httpServletRequest, httpServletResponse);
        460â”†         String indexName = this.indexHelper.getIndexNameOrAlias(init.getParamsMap(),"index","alias",this.indexAPI);
        461â”†         APILocator.getESIndexAPI().openIndex(indexName);
        462â”† 
        463â”†         return Response.ok().build();
          [shortened a long line from output, adjust with --max-chars-per-line]
           [hid 5 additional lines, adjust with --max-lines-per-finding] 
        528â”† @CloseDBIfOpened
        529â”† @PUT
        530â”† @JSONP
        531â”† @NoCache
        532â”† @Path("/{indexName: .*}")
        533â”† @Produces({MediaType.APPLICATION_JSON})
        534â”† public Response modIndex(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
        535â”†                 @PathParam("indexName") final String indexName, @QueryParam("action") final String action) throws DotDataException, IOException {
        536â”† 
        537â”†     final InitDataObject init = auth(request, response);
           [hid 32 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/languages/LanguagesResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

         71â”† @POST
         72â”† @JSONP
         73â”† @NoCache
         74â”† @Path("/i18n")
         75â”† @InitRequestRequired
         76â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
         77â”† /**
         78â”†  * @deprecated use {@link LanguagesResource#getMessages(HttpServletRequest, I18NForm)} instead
         79â”†  */
         80â”† public Response getMessages(@Context HttpServletRequest request,
           [hid 26 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/notification/NotificationResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        236â”† @PUT
        237â”† @Path ("/markAsRead")
        238â”† @Produces ("application/json")
        239â”† public Response markAsRead ( @Context final HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse )  {
        240â”† 
        241â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
        242â”†             .requiredBackendUser(true)
        243â”†             .requiredFrontendUser(false)
        244â”†             .requestAndResponse(httpServletRequest, httpServletResponse)
        245â”†             .rejectWhenNoUser(true).init();
           [hid 23 additional lines, adjust with --max-lines-per-finding] 
        276â”† @DELETE
        277â”† @Path("/id/{id}")
        278â”† @Produces ("application/json")
        279â”† public Response delete(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam("id") String groupId)  ... [0m
        280â”† 
        281â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
        282â”†             .requiredBackendUser(true)
        283â”†             .requiredFrontendUser(false)
        284â”†             .requestAndResponse(httpServletRequest, httpServletResponse)
        285â”†             .rejectWhenNoUser(true).init();
          [shortened a long line from output, adjust with --max-chars-per-line]
           [hid 24 additional lines, adjust with --max-lines-per-finding] 
        321â”† @PUT
        322â”† @Path("/delete")
        323â”† @Produces ("application/json")
        324â”† public Response delete ( @Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, final DeleteForm deleteForm )   ... [0m
        325â”† 
        326â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
        327â”†             .requiredBackendUser(true)
        328â”†             .requiredFrontendUser(false)
        329â”†             .requestAndResponse(httpServletRequest, httpServletResponse)
        330â”†             .rejectWhenNoUser(true).init();
          [shortened a long line from output, adjust with --max-chars-per-line]
           [hid 24 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/page/PageResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        315â”† @NoCache
        316â”† @POST
        317â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        318â”† @Path("/{pageId}/layout")
        319â”† public Response saveLayout(@Context final HttpServletRequest request,
        320â”†         @Context final HttpServletResponse response,
        321â”†         @PathParam("pageId") final String pageId,
        322â”†         @QueryParam("variantName") final String variantNameParam,
        323â”†         final PageForm form) throws DotSecurityException {
        324â”† 
           [hid 46 additional lines, adjust with --max-lines-per-finding] 
        381â”† @NoCache
        382â”† @POST
        383â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        384â”† @Path("/layout")
        385â”† public Response saveLayout(@Context final HttpServletRequest request, @Context final HttpServletResponse response, final PageForm form) throws DotDataException  ... [0m
        386â”† 
        387â”†     final InitDataObject auth = webResource.init(request, response, true);
        388â”†     final User user = auth.getUser();
        389â”† 
        390â”†     Response res = null;
          [shortened a long line from output, adjust with --max-chars-per-line]
           [hid 25 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/personalization/PersonalizationResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

         82â”† @POST
         83â”† @Path("/pagepersonas")
         84â”† @JSONP
         85â”† @NoCache
         86â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
         87â”† public Response personalizePageContainers (@Context final HttpServletRequest  request,
         88â”†                                            @Context final HttpServletResponse response,
         89â”†                                            final PersonalizationPersonaPageForm personalizationPersonaPageForm) throws DotDataException, DotSecurityException {
         90â”† 
         91â”†     final User user = this.webResource.init(true, request, true).getUser();
           [hid 28 additional lines, adjust with --max-lines-per-finding] 
        129â”† @DELETE
        130â”† @Path("/pagepersonas/page/{pageId}/personalization/{personalization}")
        131â”† @JSONP
        132â”† @NoCache
        133â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        134â”† public Response personalizePageContainers (@Context final HttpServletRequest  request,
        135â”†                                            @Context final HttpServletResponse response,
        136â”†                                            @PathParam("pageId") final String  pageId,
        137â”†                                            @PathParam("personalization") final String personalization) throws DotDataException, DotSecurityException {
        138â”† 
           [hid 28 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/portlet/ToolGroupResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

         58â”† @PUT
         59â”† @Path("/{layoutId}/_removefromuser")
         60â”† @JSONP
         61â”† @NoCache
         62â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
         63â”† public final Response deleteToolGroupFromUser(@Context final HttpServletRequest request,
         64â”†         @Context final HttpServletResponse response,
         65â”†         @PathParam("layoutId") final String layoutId, @QueryParam("userid") final String userid)
         66â”†         throws DotDataException, DotSecurityException {
         67â”† 
           [hid 23 additional lines, adjust with --max-lines-per-finding] 
         98â”† @PUT
         99â”† @Path("/{layoutId}/_addtouser")
        100â”† @JSONP
        101â”† @NoCache
        102â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        103â”† public final Response addToolGroupToUser(@Context final HttpServletRequest request,
        104â”†         @Context final HttpServletResponse response,
        105â”†         @PathParam("layoutId") final String layoutId, @QueryParam("userid") final String userid)
        106â”†         throws DotDataException, DotSecurityException {
        107â”† 
           [hid 22 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/pushpublish/PushPublishFilterResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        387â”† @DELETE
        388â”† @Path("/{filterKey}")
        389â”† @JSONP
        390â”† @NoCache
        391â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        392â”† public final Response deleteFilter(@Context final HttpServletRequest request,
        393â”†                                  @Context final HttpServletResponse response,
        394â”†                                  @PathParam("filterKey") final String filterKey) throws DotDataException {
        395â”† 
        396â”†     final InitDataObject initData =
           [hid 22 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/site/SiteResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        260â”† @PUT
        261â”† @Path ("/switch/{id}")
        262â”† @JSONP
        263â”† @NoCache
        264â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        265â”† public final Response switchSite(
        266â”†         @Context final HttpServletRequest httpServletRequest,
        267â”†         @Context final HttpServletResponse httpServletResponse,
        268â”†         @PathParam("id")   final String hostId
        269â”† ) {
           [hid 38 additional lines, adjust with --max-lines-per-finding] 
        315â”† @PUT
        316â”† @Path ("/switch")
        317â”† @JSONP
        318â”† @NoCache
        319â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        320â”† public final Response switchSite(
        321â”†         @Context final HttpServletRequest request,
        322â”†         @Context final HttpServletResponse response
        323â”† ) {
        324â”† 
           [hid 21 additional lines, adjust with --max-lines-per-finding] 
        409â”† @PUT
        410â”† @Path("/{siteId}/_publish")
        411â”† @JSONP
        412â”† @NoCache
        413â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        414â”† public Response publishSite(@Context final HttpServletRequest httpServletRequest,
        415â”†                             @Context final HttpServletResponse httpServletResponse,
        416â”†                             @PathParam("siteId") final String siteId) throws DotDataException, DotSecurityException {
        417â”† 
        418â”†     final User user = new WebResource.InitBuilder(this.webResource)
           [hid 17 additional lines, adjust with --max-lines-per-finding] 
        448â”† @PUT
        449â”† @Path("/{siteId}/_unpublish")
        450â”† @JSONP
        451â”† @NoCache
        452â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        453â”† public Response unpublishSite(@Context final HttpServletRequest httpServletRequest,
        454â”†                               @Context final HttpServletResponse httpServletResponse,
        455â”†                               @PathParam("siteId") final String siteId) throws DotDataException, DotSecurityException {
        456â”† 
        457â”†     final User user = new WebResource.InitBuilder(this.webResource)
           [hid 19 additional lines, adjust with --max-lines-per-finding] 
        489â”† @PUT
        490â”† @Path("/{siteId}/_archive")
        491â”† @JSONP
        492â”† @NoCache
        493â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        494â”† public Response archiveSite(@Context final HttpServletRequest httpServletRequest,
        495â”†                             @Context final HttpServletResponse httpServletResponse,
        496â”†                             @PathParam("siteId")  final String siteId) throws DotDataException, DotSecurityException{
        497â”† 
        498â”†     final User user = new WebResource.InitBuilder(this.webResource)
           [hid 24 additional lines, adjust with --max-lines-per-finding] 
        548â”† @PUT
        549â”† @Path("/{siteId}/_unarchive")
        550â”† @JSONP
        551â”† @NoCache
        552â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        553â”† public Response unarchiveSite(@Context final HttpServletRequest httpServletRequest,
        554â”†                               @Context final HttpServletResponse httpServletResponse,
        555â”†                               @PathParam("siteId")  final String siteId) throws DotDataException, DotSecurityException {
        556â”† 
        557â”†     final User user = new WebResource.InitBuilder(this.webResource)
           [hid 19 additional lines, adjust with --max-lines-per-finding] 
        590â”† @DELETE
        591â”† @Path("/{siteId}")
        592â”† @JSONP
        593â”† @NoCache
        594â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        595â”† public void deleteSite(@Context final HttpServletRequest httpServletRequest,
        596â”†                             @Context final HttpServletResponse httpServletResponse,
        597â”†                             @Suspended final AsyncResponse asyncResponse,
        598â”†                             @PathParam("siteId")  final String siteId) throws DotDataException, DotSecurityException {
        599â”† 
           [hid 36 additional lines, adjust with --max-lines-per-finding] 
        649â”† @PUT
        650â”† @Path("/{siteId}/_makedefault")
        651â”† @JSONP
        652â”† @NoCache
        653â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        654â”† public Response makeDefault(@Context final HttpServletRequest httpServletRequest,
        655â”†                        @Context final HttpServletResponse httpServletResponse,
        656â”†                        @PathParam("siteId")  final String siteId) throws DotDataException, DotSecurityException {
        657â”† 
        658â”†     final User user = new WebResource.InitBuilder(this.webResource)
           [hid 20 additional lines, adjust with --max-lines-per-finding] 
        764â”† @POST
        765â”† @Path("/_byname")
        766â”† @JSONP
        767â”† @NoCache
        768â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        769â”† public Response findHostByName(@Context final HttpServletRequest httpServletRequest,
        770â”†                              @Context final HttpServletResponse httpServletResponse,
        771â”†                              final SearchSiteByNameForm searchSiteByNameForm) throws DotDataException, DotSecurityException {
        772â”† 
        773â”†     final User user = new WebResource.InitBuilder(this.webResource)
           [hid 23 additional lines, adjust with --max-lines-per-finding] 
        911â”† @PUT
        912â”† @Path("/variable")
        913â”† @JSONP
        914â”† @NoCache
        915â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        916â”† @Operation(summary = "Save a Site Variable",
        917â”†         responses = {
        918â”†                 @ApiResponse(
        919â”†                         responseCode = "200",
        920â”†                         content = @Content(mediaType = "application/json",
           [hid 68 additional lines, adjust with --max-lines-per-finding] 
       1223â”† @PUT
       1224â”† @Path("/_copy")
       1225â”† @JSONP
       1226â”† @NoCache
       1227â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1228â”† public Response copySite(@Context final HttpServletRequest httpServletRequest,
       1229â”†                               @Context final HttpServletResponse httpServletResponse,
       1230â”†                               final CopySiteForm copySiteForm)
       1231â”†         throws DotDataException, DotSecurityException, PortalException, SystemException, ParseException, SchedulerException, ClassNotFoundException, AlreadyExis ... [0m
       1232â”† 
          [shortened a long line from output, adjust with --max-chars-per-line]
           [hid 33 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/sites/ruleengine/rules/RuleResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        163â”† @DELETE
        164â”† @Path("/rules/{ruleId}")
        165â”† public Response remove(@Context HttpServletRequest request, @Context final HttpServletResponse response, @PathParam("siteId") String siteId, @PathParam("ruleId" ... [0m
        166â”†     User user = getUser(request, response);
        167â”† 
        168â”†     try {
        169â”†         Ruleable proxy =  getParent(siteId, user);
        170â”†         Rule rule = getRule(ruleId, user);
        171â”†         HibernateUtil.startTransaction();
        172â”†         rulesAPI.deleteRule(rule, user, false);
          [shortened a long line from output, adjust with --max-chars-per-line]
           [hid 10 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/sites/ruleengine/rules/conditions/ConditionGroupResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        172â”† @DELETE
        173â”† @Path("/rules/{ruleId}/conditionGroups/{conditionGroupId}")
        174â”† public Response remove(@Context HttpServletRequest request,
        175â”†                        @Context final HttpServletResponse response,
        176â”†                                      @PathParam("siteId") String siteId,
        177â”†                                      @PathParam("ruleId") String ruleId,
        178â”†                                      @PathParam("conditionGroupId") String groupId) throws JSONException {
        179â”†     User user = getUser(request, response);
        180â”† 
        181â”†     try {
           [hid 13 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/sites/ruleengine/rules/conditions/ConditionResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        151â”† @DELETE
        152â”† @Path("/conditions/{conditionId}")
        153â”† public Response remove(@Context HttpServletRequest request, @Context final HttpServletResponse response, @PathParam("siteId") String siteId, @PathParam("conditi ... [0m
        154â”†         throws JSONException {
        155â”†     User user = getUser(request, response);
        156â”† 
        157â”†     try {
        158â”†         getHost(siteId, user);
        159â”†         Condition condition = getCondition(conditionId, user);
        160â”†         rulesAPI.deleteCondition(condition, user, false);
          [shortened a long line from output, adjust with --max-chars-per-line]
           [hid 8 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/sites/ruleengine/rules/conditions/ConditionValueResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        178â”† @DELETE
        179â”† @Path("/conditions/{conditionId}/conditionValues/{valueId}")
        180â”† public Response remove(@Context HttpServletRequest request,
        181â”†                        @Context final HttpServletResponse response,
        182â”†                        @PathParam("siteId") String siteId,
        183â”†                        @PathParam("conditionId") String conditionId,
        184â”†                        @PathParam("valueId") String valueId)
        185â”†         throws JSONException {
        186â”†     User user = getUser(request, response);
        187â”† 
           [hid 15 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/system/ConfigurationResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        198â”† @POST
        199â”† @Path("/_validateCompanyEmail")
        200â”† @JSONP
        201â”† @NoCache
        202â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        203â”† public Response validateEmail(
        204â”† 		@Context final HttpServletRequest request,
        205â”† 		@Context final HttpServletResponse response,
        206â”† 		final CompanyEmailForm form) throws ExecutionException, InterruptedException {
        207â”† 
           [hid 10 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/system/cache/CacheResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        264â”† @NoCache
        265â”† @DELETE
        266â”† @Path("/provider/{provider: .*}/flush/{group: .*}")
        267â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        268â”† public Response flushGroup(@Context final HttpServletRequest request,
        269â”†                            @Context final HttpServletResponse response,
        270â”†                            @PathParam("provider") final String provider,
        271â”†                            @PathParam("group") final String group) {
        272â”† 
        273â”†     new WebResource.InitBuilder(webResource)
           [hid 12 additional lines, adjust with --max-lines-per-finding] 
        295â”† @NoCache
        296â”† @DELETE
        297â”† @Path("/provider/{provider: .*}/flush/{group: .*}/{id: .*}")
        298â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        299â”† public Response flushObject(@Context final HttpServletRequest request,
        300â”†                             @Context final HttpServletResponse response,
        301â”†                             @PathParam("provider") final String provider,
        302â”†                             @PathParam("group") final String group,
        303â”†                             @PathParam("id") final String id) {
        304â”† 
           [hid 13 additional lines, adjust with --max-lines-per-finding] 
        326â”† @NoCache
        327â”† @DELETE
        328â”† @Path("/provider/{provider: .*}/flush")
        329â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        330â”† public Response flushAll(@Context final HttpServletRequest request,
        331â”†                             @Context final HttpServletResponse response,
        332â”†                             @PathParam("provider") final String provider) {
        333â”† 
        334â”†     new WebResource.InitBuilder(webResource)
        335â”†             .requestAndResponse(request, response)
           [hid 10 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/system/redis/RedisResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        125â”† @NoCache
        126â”† @DELETE
        127â”† @Path("/{key}")
        128â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        129â”† public Response delete(@Context final HttpServletRequest request,
        130â”†                     @Context final HttpServletResponse response,
        131â”†                     @PathParam("key") final String key) {
        132â”† 
        133â”†     new WebResource.InitBuilder(webResource)
        134â”†             .requestAndResponse(request, response)
           [hid 7 additional lines, adjust with --max-lines-per-finding] 
        144â”† @NoCache
        145â”† @PUT
        146â”† @Path("/hash")
        147â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        148â”† public Response setHash(@Context final HttpServletRequest request,
        149â”†                     @Context final HttpServletResponse response,
        150â”†                     final SetHashForm setForm) {
        151â”† 
        152â”†     new WebResource.InitBuilder(webResource)
        153â”†             .requestAndResponse(request, response)
           [hid 8 additional lines, adjust with --max-lines-per-finding] 
        181â”† @NoCache
        182â”† @DELETE
        183â”† @Path("/hash/{key}")
        184â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        185â”† public Response deleteHash(@Context final HttpServletRequest request,
        186â”†                        @Context final HttpServletResponse response,
        187â”†                        @PathParam("key") final String key) {
        188â”† 
        189â”†     new WebResource.InitBuilder(webResource)
        190â”†             .requestAndResponse(request, response)
           [hid 12 additional lines, adjust with --max-lines-per-finding] 
        205â”† @NoCache
        206â”† @PUT
        207â”† @Path("/incr/{key}")
        208â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        209â”† public void incrementAsync(@Context final HttpServletRequest request,
        210â”†                         @Context final HttpServletResponse response,
        211â”†                         @Suspended final AsyncResponse asyncResponse,
        212â”†                         @PathParam("key") final String key) {
        213â”† 
        214â”†     new WebResource.InitBuilder(webResource)
           [hid 17 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/system/role/RoleResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        148â”† @DELETE
        149â”† @Path("/layouts")
        150â”† @Produces("application/json")
        151â”† public Response deleteRoleLayouts(
        152â”† 		final @Context HttpServletRequest request,
        153â”† 		final @Context HttpServletResponse response,
        154â”† 		final RoleLayoutForm roleLayoutForm) throws DotDataException, DotSecurityException {
        155â”† 
        156â”† 	final InitDataObject initDataObject = new WebResource.InitBuilder()
        157â”† 			.requiredFrontendUser(false).rejectWhenNoUser(true)
           [hid 23 additional lines, adjust with --max-lines-per-finding] 
        186â”† @POST
        187â”† @Path("/layouts")
        188â”† @Produces("application/json")
        189â”† public Response saveRoleLayouts(
        190â”† 		final @Context HttpServletRequest request,
        191â”† 		final @Context HttpServletResponse response,
        192â”† 		final RoleLayoutForm roleLayoutForm) throws DotDataException, DotSecurityException {
        193â”† 
        194â”† 	final InitDataObject initDataObject = new WebResource.InitBuilder(this.webResource)
        195â”† 			.requiredFrontendUser(false).rejectWhenNoUser(true)
           [hid 23 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/temp/TempFileAPI.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.httpservlet-path-traversal
        Detected a potential path traversal. A malicious actor could control the location of this
        file, to include going backwards in the directory with '../'. To address this, ensure that
        user-controlled variables in file paths are sanitized. You may also consider using a utility
        method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file
        name from the path.

        169â”† final File tempFile = dotTempFile.file;
          â‹®â”†----------------------------------------
        209â”† final File tempFile = dotTempFile.file;


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/template/TemplateResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        318â”† @PUT
        319â”† @Path("/draft")
        320â”† @JSONP
        321â”† @NoCache
        322â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        323â”† public final Response saveDraft(@Context final HttpServletRequest  request,
        324â”†                            @Context final HttpServletResponse response,
        325â”†                            final TemplateForm templateForm) throws DotDataException, DotSecurityException {
        326â”† 
        327â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 17 additional lines, adjust with --max-lines-per-finding] 
        422â”† @PUT
        423â”† @Path("/_savepublish")
        424â”† @JSONP
        425â”† @NoCache
        426â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        427â”† public final Response saveAndPublish(@Context final HttpServletRequest  request,
        428â”†                            @Context final HttpServletResponse response,
        429â”†                            final TemplateForm templateForm) throws DotDataException, DotSecurityException {
        430â”† 
        431â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 20 additional lines, adjust with --max-lines-per-finding] 
        493â”† @PUT
        494â”† @Path("/_publish")
        495â”† @JSONP
        496â”† @NoCache
        497â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        498â”† public final Response publish(@Context final HttpServletRequest  request,
        499â”†                            @Context final HttpServletResponse response,
        500â”†                            final List<String> templatesToPublish){
        501â”† 
        502â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 34 additional lines, adjust with --max-lines-per-finding] 
        552â”† @PUT
        553â”† @Path("/_unpublish")
        554â”† @JSONP
        555â”† @NoCache
        556â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        557â”† public final Response unpublish(@Context final HttpServletRequest  request,
        558â”†                               @Context final HttpServletResponse response,
        559â”†                               final List<String> templatesToUnpublish) {
        560â”† 
        561â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 34 additional lines, adjust with --max-lines-per-finding] 
        606â”† @PUT
        607â”† @Path("/{templateId}/_copy")
        608â”† @JSONP
        609â”† @NoCache
        610â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        611â”† public final Response copy(@Context final HttpServletRequest  request,
        612â”†                            @Context final HttpServletResponse response,
        613â”†                            @PathParam("templateId") final String templateId) throws DotDataException, DotSecurityException {
        614â”† 
        615â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 16 additional lines, adjust with --max-lines-per-finding] 
        647â”† @PUT
        648â”† @Path("/_archive")
        649â”† @JSONP
        650â”† @NoCache
        651â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        652â”† public final Response archive(@Context final HttpServletRequest  request,
        653â”†                              @Context final HttpServletResponse response,
        654â”†                              final List<String> templatesToArchive) {
        655â”† 
        656â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 34 additional lines, adjust with --max-lines-per-finding] 
        706â”† @PUT
        707â”† @Path("/_unarchive")
        708â”† @JSONP
        709â”† @NoCache
        710â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        711â”† public final Response unarchive(@Context final HttpServletRequest  request,
        712â”†         @Context final HttpServletResponse response,
        713â”†         final List<String> templatesToUnarchive){
        714â”† 
        715â”†     final InitDataObject initData = new WebResource.InitBuilder(webResource)
           [hid 34 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/user/UserResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        193â”† @PUT
        194â”† @JSONP
        195â”† @Path("/current")
        196â”† @NoCache
        197â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        198â”† public final Response update(@Context final HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse,
        199â”† 							 final UpdateUserForm updateUserForm) throws Exception {
        200â”† 
        201â”† 	final User modUser = new WebResource.InitBuilder(webResource)
        202â”† 			.requiredBackendUser(true)
           [hid 63 additional lines, adjust with --max-lines-per-finding] 
        379â”† @POST
        380â”† @Path("/loginas")
        381â”† @JSONP
        382â”† @NoCache
        383â”† @Produces({ MediaType.APPLICATION_JSON, "application/javascript" })
        384â”† public final Response loginAs(@Context final HttpServletRequest request, @Context final HttpServletResponse httpResponse, final LoginAsForm loginAsForm) throws  ... [0m
        385â”† 	final String loginAsUserId = loginAsForm.getUserId();
        386â”† 	final String loginAsUserPwd = loginAsForm.getPassword();
        387â”† 
        388â”† 	final InitDataObject initData = new WebResource.InitBuilder(webResource)
          [shortened a long line from output, adjust with --max-chars-per-line]
           [hid 53 additional lines, adjust with --max-lines-per-finding] 
        534â”† @PUT
        535â”† @Path("/logoutas")
        536â”† @JSONP
        537â”† @NoCache
        538â”† @Produces({ MediaType.APPLICATION_JSON, "application/javascript" })
        539â”† public final Response logoutAs(@Context final HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse) {
        540â”† 
        541â”† 	new WebResource.InitBuilder(webResource)
        542â”† 			.requiredBackendUser(true)
        543â”† 			.requiredFrontendUser(false)
           [hid 34 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v1/workflow/WorkflowResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        518â”† @POST
        519â”† @Path("/contentlet/actions/bulk")
        520â”† @JSONP
        521â”† @NoCache
        522â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        523â”† public final Response getBulkActions(@Context final HttpServletRequest request,
        524â”†                                      @Context final HttpServletResponse response,
        525â”†                                      final BulkActionForm bulkActionForm) {
        526â”† 
        527â”†     final InitDataObject initDataObject = this.webResource.init
           [hid 15 additional lines, adjust with --max-lines-per-finding] 
        544â”† @PUT
        545â”† @Path("/contentlet/actions/bulk/fire")
        546â”† @JSONP
        547â”† @NoCache
        548â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        549â”† public final void fireBulkActions(@Context final HttpServletRequest request,
        550â”†                                   @Suspended final AsyncResponse asyncResponse,
        551â”†                                   final FireBulkActionsForm fireBulkActionsForm) {
        552â”† 
        553â”†     final InitDataObject initDataObject = this.webResource.init(null, request, new EmptyHttpResponse(), true, null);
           [hid 20 additional lines, adjust with --max-lines-per-finding] 
        575â”† @POST
        576â”† @Path("/contentlet/actions/_bulkfire")
        577â”† @JSONP
        578â”† @Produces(SseFeature.SERVER_SENT_EVENTS)
        579â”† public EventOutput fireBulkActions(@Context final HttpServletRequest request,
        580â”†         final FireBulkActionsForm fireBulkActionsForm)
        581â”†         throws DotDataException, DotSecurityException {
        582â”†     final InitDataObject initDataObject = this.webResource
        583â”†             .init(null, request, new EmptyHttpResponse(), true, null);
        584â”† 
           [hid 46 additional lines, adjust with --max-lines-per-finding] 
        794â”† @POST
        795â”† @Path("/schemes/actions/{systemAction}")
        796â”† @JSONP
        797â”† @NoCache
        798â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        799â”† public final Response findActionsBySchemesAndSystemAction(@Context final HttpServletRequest request,
        800â”†                                                 @Context final HttpServletResponse response,
        801â”†                                                 @PathParam("systemAction") final WorkflowAPI.SystemAction systemAction,
        802â”†                                                 final WorkflowSchemesForm workflowSchemesForm) {
        803â”† 
           [hid 20 additional lines, adjust with --max-lines-per-finding] 
        931â”† @PUT
        932â”† @Path("/system/actions")
        933â”† @JSONP
        934â”† @NoCache
        935â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        936â”† public final Response saveSystemAction(@Context final HttpServletRequest request,
        937â”†                                  @Context final HttpServletResponse response,
        938â”†                                  final WorkflowSystemActionForm workflowSystemActionForm) {
        939â”† 
        940â”†     final InitDataObject initDataObject = this.webResource.init
           [hid 22 additional lines, adjust with --max-lines-per-finding] 
        973â”† @DELETE
        974â”† @Path("/system/actions/{identifier}")
        975â”† @JSONP
        976â”† @NoCache
        977â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        978â”† public final Response deletesSystemAction(@Context final HttpServletRequest request,
        979â”†                                           @Context final HttpServletResponse response,
        980â”†                                           @PathParam("identifier") final String identifier) {
        981â”† 
        982â”†     final InitDataObject initDataObject = this.webResource.init
           [hid 17 additional lines, adjust with --max-lines-per-finding] 
       1044â”† @PUT
       1045â”† @Path("/actions/{actionId}")
       1046â”† @JSONP
       1047â”† @NoCache
       1048â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1049â”† public final Response updateAction(@Context final HttpServletRequest request,
       1050â”†                                    @Context final HttpServletResponse response,
       1051â”†                                    @PathParam("actionId") final String actionId,
       1052â”†                                    final WorkflowActionForm workflowActionForm) {
       1053â”† 
           [hid 14 additional lines, adjust with --max-lines-per-finding] 
       1075â”† @POST
       1076â”† @Path("/steps/{stepId}/actions")
       1077â”† @JSONP
       1078â”† @NoCache
       1079â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1080â”† public final Response saveActionToStep(@Context final HttpServletRequest request,
       1081â”†                                        @Context final HttpServletResponse response,
       1082â”†                                        @PathParam("stepId")   final String stepId,
       1083â”†                                        final WorkflowActionStepForm workflowActionStepForm) {
       1084â”† 
           [hid 16 additional lines, adjust with --max-lines-per-finding] 
       1109â”† @POST
       1110â”† @Path("/actions/{actionId}/actionlets")
       1111â”† @JSONP
       1112â”† @NoCache
       1113â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1114â”† public final Response saveActionletToAction(@Context final HttpServletRequest request,
       1115â”†                                             @PathParam("actionId")   final String actionId,
       1116â”†                                             final WorkflowActionletActionForm workflowActionletActionForm) {
       1117â”† 
       1118â”†     final InitDataObject initDataObject = this.webResource.init
           [hid 19 additional lines, adjust with --max-lines-per-finding] 
       1146â”† @DELETE
       1147â”† @Path("/steps/{stepId}")
       1148â”† @JSONP
       1149â”† @NoCache
       1150â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1151â”† public final void deleteStep(@Context final HttpServletRequest request,
       1152â”†                              @Suspended final AsyncResponse asyncResponse,
       1153â”†                              @PathParam("stepId") final String stepId) {
       1154â”† 
       1155â”†     final InitDataObject initDataObject = this.webResource.init
           [hid 12 additional lines, adjust with --max-lines-per-finding] 
       1175â”† @DELETE
       1176â”† @Path("/steps/{stepId}/actions/{actionId}")
       1177â”† @JSONP
       1178â”† @NoCache
       1179â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1180â”† public final Response deleteAction(@Context final HttpServletRequest request,
       1181â”†                                    @Context final HttpServletResponse response,
       1182â”†                                    @PathParam("actionId") final String actionId,
       1183â”†                                    @PathParam("stepId")   final String stepId) {
       1184â”† 
           [hid 16 additional lines, adjust with --max-lines-per-finding] 
       1208â”† @DELETE
       1209â”† @Path("/actions/{actionId}")
       1210â”† @JSONP
       1211â”† @NoCache
       1212â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1213â”† public final Response deleteAction(@Context final HttpServletRequest request,
       1214â”†                                    @Context final HttpServletResponse response,
       1215â”†                                    @PathParam("actionId") final String actionId) {
       1216â”† 
       1217â”†     final InitDataObject initDataObject = this.webResource.init
           [hid 15 additional lines, adjust with --max-lines-per-finding] 
       1240â”† @DELETE
       1241â”† @Path("/actionlets/{actionletId}")
       1242â”† @JSONP
       1243â”† @NoCache
       1244â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1245â”† public final Response deleteActionlet(@Context final HttpServletRequest request,
       1246â”†                                       @PathParam("actionletId") final String actionletId) {
       1247â”† 
       1248â”†     final InitDataObject initDataObject = this.webResource.init
       1249â”†             (null, true, request, true, null);
           [hid 25 additional lines, adjust with --max-lines-per-finding] 
       1283â”† @PUT
       1284â”† @Path("/reorder/step/{stepId}/order/{order}")
       1285â”† @JSONP
       1286â”† @NoCache
       1287â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1288â”† public final Response reorderStep(@Context final HttpServletRequest request,
       1289â”†                                   @Context final HttpServletResponse response,
       1290â”†                                     @PathParam("stepId")   final String stepId,
       1291â”†                                   @PathParam("order")    final int order) {
       1292â”†     final InitDataObject initDataObject = this.webResource.init
           [hid 14 additional lines, adjust with --max-lines-per-finding] 
       1316â”† @PUT
       1317â”† @Path("/steps/{stepId}")
       1318â”† @JSONP
       1319â”† @NoCache
       1320â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1321â”† public final Response updateStep(@Context final HttpServletRequest request,
       1322â”†                                  @Context final HttpServletResponse response,
       1323â”†                                  @NotNull @PathParam("stepId") final String stepId,
       1324â”†                                  final WorkflowStepUpdateForm stepForm) {
       1325â”†     final InitDataObject initDataObject = this.webResource.init(null, request, response, true, null);
           [hid 12 additional lines, adjust with --max-lines-per-finding] 
       1345â”† @POST
       1346â”† @Path("/steps")
       1347â”† @JSONP
       1348â”† @NoCache
       1349â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1350â”† public final Response addStep(@Context final HttpServletRequest request,
       1351â”†                               @Context final HttpServletResponse response,
       1352â”†                               final WorkflowStepAddForm newStepForm) {
       1353â”†     String schemeId = null;
       1354â”†     try {
           [hid 13 additional lines, adjust with --max-lines-per-finding] 
       1893â”† @PATCH()
       1894â”† @Path("/actions/default/fire/{systemAction}")
       1895â”† @JSONP
       1896â”† @NoCache
       1897â”† //@Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       1898â”† @Produces("application/octet-stream")
       1899â”† public final Response fireMergeActionDefault(@Context final HttpServletRequest request,
       1900â”†                                         @Context final HttpServletResponse response,
       1901â”†                                         @QueryParam("inode")            final String inode,
       1902â”†                                         @QueryParam("identifier")       final String identifier,
           [hid 40 additional lines, adjust with --max-lines-per-finding] 
       2792â”† @PUT
       2793â”† @Path("/reorder/steps/{stepId}/actions/{actionId}")
       2794â”† @JSONP
       2795â”† @NoCache
       2796â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       2797â”† public final Response reorderAction(@Context final HttpServletRequest request,
       2798â”†                                     @Context final HttpServletResponse response,
       2799â”†                                     @PathParam("stepId")   final String stepId,
       2800â”†                                     @PathParam("actionId") final String actionId,
       2801â”†                                     final WorkflowReorderWorkflowActionStepForm workflowReorderActionStepForm) {
           [hid 20 additional lines, adjust with --max-lines-per-finding] 
       2830â”† @POST
       2831â”† @Path("/schemes/import")
       2832â”† @JSONP
       2833â”† @NoCache
       2834â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       2835â”† public final Response importScheme(@Context final HttpServletRequest  httpServletRequest,
       2836â”†                                    @Context final HttpServletResponse httpServletResponse,
       2837â”†                                    final WorkflowSchemeImportObjectForm workflowSchemeImportForm) {
       2838â”† 
       2839â”†     final InitDataObject initDataObject = this.webResource.init
           [hid 32 additional lines, adjust with --max-lines-per-finding] 
       2925â”† @POST
       2926â”† @Path("/schemes/{schemeId}/copy")
       2927â”† @JSONP
       2928â”† @NoCache
       2929â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       2930â”† public final Response copyScheme(@Context final HttpServletRequest httpServletRequest,
       2931â”†                                  @Context final HttpServletResponse httpServletResponse,
       2932â”†                                  @PathParam("schemeId") final String schemeId,
       2933â”†                                  @QueryParam("name") final String name,
       2934â”†                                  final WorkflowCopyForm workflowCopyForm) {
           [hid 29 additional lines, adjust with --max-lines-per-finding] 
       3073â”† @POST
       3074â”† @Path("/schemes")
       3075â”† @JSONP
       3076â”† @NoCache
       3077â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       3078â”† public final Response saveScheme(@Context final HttpServletRequest request,
       3079â”†                                  @Context final HttpServletResponse response,
       3080â”†                            final WorkflowSchemeForm workflowSchemeForm) {
       3081â”†     final InitDataObject initDataObject = this.webResource.init(null, request, response, true, null);
       3082â”†     try {
           [hid 10 additional lines, adjust with --max-lines-per-finding] 
       3101â”† @PUT
       3102â”† @Path("/schemes/{schemeId}")
       3103â”† @JSONP
       3104â”† @NoCache
       3105â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       3106â”† public final Response updateScheme(@Context final HttpServletRequest request,
       3107â”†                                    @Context final HttpServletResponse response,
       3108â”†                              @PathParam("schemeId") final String schemeId,
       3109â”†                                    final WorkflowSchemeForm workflowSchemeForm) {
       3110â”†     final InitDataObject initDataObject = this.webResource.init(null, request, response, true, null);
           [hid 11 additional lines, adjust with --max-lines-per-finding] 
       3128â”† @DELETE
       3129â”† @Path("/schemes/{schemeId}")
       3130â”† @JSONP
       3131â”† @NoCache
       3132â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
       3133â”† public final void deleteScheme(@Context final HttpServletRequest request,
       3134â”†                                @Suspended final AsyncResponse asyncResponse,
       3135â”†                                @PathParam("schemeId") final String schemeId) {
       3136â”† 
       3137â”†     final InitDataObject initDataObject = this.webResource.init(null, request,new EmptyHttpResponse(), true, null);
           [hid 10 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v2/contenttype/FieldResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        351â”† @DELETE
        352â”† @Path("/id/{fieldId}")
        353â”† @JSONP
        354â”† @NoCache
        355â”† @Produces({ MediaType.APPLICATION_JSON, "application/javascript" })
        356â”† public Response deleteContentTypeFieldById(
        357â”†         @PathParam("fieldId") final String fieldId,
        358â”†         @Context final HttpServletRequest httpServletRequest,
        359â”†         @Context final HttpServletResponse httpServletResponse)
        360â”†         throws DotDataException, DotSecurityException {
           [hid 19 additional lines, adjust with --max-lines-per-finding] 
        381â”† @DELETE
        382â”† @Path("/var/{fieldVar}")
        383â”† @JSONP
        384â”† @NoCache
        385â”† @Produces({ MediaType.APPLICATION_JSON, "application/javascript" })
        386â”† public Response deleteContentTypeFieldByVar(@PathParam("typeIdOrVarName") final String typeIdOrVarName,
        387â”†         @PathParam("fieldVar") final String fieldVar,
        388â”†         @Context final HttpServletRequest httpServletRequest,
        389â”†         @Context final HttpServletResponse httpServletResponse)
        390â”†         throws DotDataException, DotSecurityException {
           [hid 21 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/api/v2/languages/LanguagesResource.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        186â”† @POST
        187â”† @JSONP
        188â”† @NoCache
        189â”† @Path("/{languageTag}")
        190â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        191â”† public final Response saveFromLanguageTag(@Context final HttpServletRequest request,
        192â”†         @Context final HttpServletResponse response,
        193â”†         @PathParam("languageTag") final String languageTag
        194â”† ) throws AlreadyExistException {
        195â”†     DotPreconditions.notNull(languageTag, "Expected languageTag Param path was empty.");
           [hid 15 additional lines, adjust with --max-lines-per-finding] 
        266â”† @PUT
        267â”† @Path("/{languageId}")
        268â”† @JSONP
        269â”† @NoCache
        270â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        271â”† public final Response updateLanguage(@Context final HttpServletRequest request,
        272â”†         @Context final HttpServletResponse response,
        273â”†         @PathParam("languageId") final String languageId,
        274â”†         final LanguageForm languageForm) throws AlreadyExistException {
        275â”†     this.webResource.init(null, request, response,
           [hid 7 additional lines, adjust with --max-lines-per-finding] 
        291â”† @DELETE
        292â”† @Path("/{languageId}")
        293â”† @JSONP
        294â”† @NoCache
        295â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        296â”† public final Response deleteLanguage(@Context final HttpServletRequest request,
        297â”†         @Context final HttpServletResponse response,
        298â”†         @PathParam("languageId") final String languageId) {
        299â”†     this.webResource.init(null, request, response,
        300â”†             true, PortletID.LANGUAGES.toString());
           [hid 6 additional lines, adjust with --max-lines-per-finding] 
        308â”† @POST
        309â”† @JSONP
        310â”† @NoCache
        311â”† @Path("/i18n")
        312â”† @InitRequestRequired
        313â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        314â”† public Response getMessages(@Context HttpServletRequest request,
        315â”†                             final I18NForm i18NForm) {
        316â”†     return oldLanguagesResource.getMessages(request, i18NForm);
        317â”† }
          â‹®â”†----------------------------------------
        447â”† @PUT
        448â”† @Path("/{language}/_makedefault")
        449â”† @JSONP
        450â”† @NoCache
        451â”† @Produces({MediaType.APPLICATION_JSON, "application/javascript"})
        452â”† public Response makeDefault(@Context final HttpServletRequest httpServletRequest,
        453â”†         @Context final HttpServletResponse httpServletResponse,
        454â”†         @PathParam("language") final Long languageId,
        455â”†         final MakeDefaultLangForm makeDefaultLangForm
        456â”† ) throws DotDataException, DotSecurityException {
           [hid 23 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/rest/elasticsearch/ESContentResourcePortlet.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.default-resteasy-provider-abuse
        When a Restful webservice endpoint isn't configured with a @Consumes  annotation, an
        attacker could abuse the SerializableProvider by sending a  HTTP Request with a Content-Type
        of application/x-java-serialized-object.  The body of that request would be processed by the
        SerializationProvider  and could contain a malicious payload, which may lead to arbitrary
        code  execution. Instead, add a @Consumes annotation to the function or class.

        166â”† 	@POST
        167â”† 	@Path("raw")
        168â”† 	@Produces(MediaType.APPLICATION_JSON)
        169â”† 	public Response searchRaw(@Context HttpServletRequest request) {
        170â”† 
        171â”†         InitDataObject initData = webResource.init(null, true, request, false, null);
        172â”† 
        173â”† 		HttpSession session = request.getSession();
        174â”† 
        175â”†         PageMode mode = PageMode.get(request);
           [hid 15 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/security/apps/AppsUtil.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.object-deserialization
        Found object deserialization using ObjectInputStream. Deserializing entire Java objects is
        dangerous because malicious actors can create Java object streams with unintended
        consequences. Ensure that the objects being deserialized are not user-controlled. If this
        must be done, consider using HMACs to sign the data stream to make sure it is not tampered
        with, or consider only transmitting object fields and populating a new object.

        336â”† return (AppsSecretsImportExport)new ObjectInputStream(inputStream).readObject();


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotcms/util/ReflectionUtils.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.formatted-sql-string
        Detected a formatted string in a SQL statement. This could lead to SQL injection if
        variables in the SQL statement are not properly sanitized. Use a prepared statements
        (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using
        'connection.prepareStatement'.

        174â”† statement.execute();


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/business/ajax/HostAjax.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.httpservlet-path-traversal
        Detected a potential path traversal. A malicious actor could control the location of this
        file, to include going backwards in the directory with '../'. To address this, ensure that
        user-controlled variables in file paths are sanitized. You may also consider using a utility
        method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file
        name from the path.

        206â”† File hostThumbnail = contentAPI.getBinaryFile(host.getInode(), Host.HOST_THUMB_KEY, user);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/business/cache/provider/h22/H22Cache.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.jdbc-sqli
        Detected a formatted string in a SQL statement. This could lead to SQL injection if
        variables in the SQL statement are not properly sanitized. Use a prepared statements
        (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using
        'connection.prepareStatement'.

        295â”† stmt.execute("truncate table " + TABLE_PREFIX + table);
          â‹®â”†----------------------------------------
        349â”† ResultSet rs = stmt.executeQuery("select DISTINCT(cache_group) from " + TABLE_PREFIX + table);
          â‹®â”†----------------------------------------
        627â”† s.execute("CREATE CACHED TABLE IF NOT EXISTS `" + TABLE_PREFIX + table
        628â”† 		+ "` (cache_id bigint PRIMARY KEY,cache_group VARCHAR(255), CACHE_DATA BLOB)");
          â‹®â”†----------------------------------------
        631â”† s.execute("CREATE INDEX IF NOT EXISTS `idx_" + TABLE_PREFIX + table + "_index_` on "
        632â”† 		+ TABLE_PREFIX + table + "(cache_group)");
          â‹®â”†----------------------------------------
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.object-deserialization
        Found object deserialization using ObjectInputStream. Deserializing entire Java objects is
        dangerous because malicious actors can create Java object streams with unintended
        consequences. Ensure that the objects being deserialized are not user-controlled. If this
        must be done, consider using HMACs to sign the data stream to make sure it is not tampered
        with, or consider only transmitting object fields and populating a new object.

        580â”† final ObjectInputStream input=new ObjectInputStream(bin);){


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/business/cache/provider/redis/RedisProvider.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.object-deserialization
        Found object deserialization using ObjectInputStream. Deserializing entire Java objects is
        dangerous because malicious actors can create Java object streams with unintended
        consequences. Ensure that the objects being deserialized are not user-controlled. If this
        must be done, consider using HMACs to sign the data stream to make sure it is not tampered
        with, or consider only transmitting object fields and populating a new object.

        224â”† input = new ObjectInputStream(bin);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/business/portal/PortletFactoryImpl.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.owasp.java.xxe.org.jdom2.input.SAXBuild
     er
        SAXBuilder being instantiated without calling the setFeature functions that are generally
        used for disabling entity processing

         77â”† SAXBuilder builder = new SAXBuilder();
          â‹®â”†----------------------------------------
         77â”† SAXBuilder builder = new SAXBuilder();
         78â”† Document doc = builder.build(fileStream);
          â‹®â”†----------------------------------------
         97â”† SAXBuilder builder = new SAXBuilder();
          â‹®â”†----------------------------------------
         97â”† SAXBuilder builder = new SAXBuilder();
         98â”† Document doc = (Document) builder.build(stream);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/common/db/DotConnect.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.formatted-sql-string
        Detected a formatted string in a SQL statement. This could lead to SQL injection if
        variables in the SQL statement are not properly sanitized. Use a prepared statements
        (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using
        'connection.prepareStatement'.

        256â”† boolean ret = stmt.execute(sql);
          â‹®â”†----------------------------------------
        264â”† boolean ret = stmt.execute(sql);
          â‹®â”†----------------------------------------
        256â”† boolean ret = stmt.execute(sql);
          â‹®â”†----------------------------------------
        264â”† boolean ret = stmt.execute(sql);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/common/db/DotDatabaseMetaData.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.formatted-sql-string
        Detected a formatted string in a SQL statement. This could lead to SQL injection if
        variables in the SQL statement are not properly sanitized. Use a prepared statements
        (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using
        'connection.prepareStatement'.

        494â”† try (final ResultSet resultSet = connection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)
        495â”†         .executeQuery("select CONSTRAINT_NAME from INFORMATION_SCHEMA.KEY_COLUMN_USAGE where CONSTRAINT_SCHEMA = SCHEMA() and TABLE_NAME = '" +
        496â”†                 tableName + "' and COLUMN_NAME = '" + columnName + "'")) {
          â‹®â”†----------------------------------------
        505â”† try (final ResultSet resultSet = connection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)
        506â”†         .executeQuery("SHOW INDEX FROM " + tableName + " where column_name = '" + columnName + "'")) {
          â‹®â”†----------------------------------------
        531â”† try (final ResultSet resultSet = statement.executeQuery("SELECT default_constraints.name FROM sys.all_columns INNER JOIN sys.tables\n" +
        532â”†         "        ON all_columns.object_id = tables.object_id\n" +
        533â”†         "        INNER JOIN sys.schemas\n" +
        534â”†         "        ON tables.schema_id = schemas.schema_id\n" +
        535â”†         "        INNER JOIN sys.default_constraints\n" +
        536â”†         "        ON all_columns.default_object_id = default_constraints.object_id\n" +
        537â”†         "WHERE tables.name = '" + tableName + "' AND all_columns.name = '" + columnName + "'")) {


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/db/DbConnectionUtil.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.formatted-sql-string
        Detected a formatted string in a SQL statement. This could lead to SQL injection if
        variables in the SQL statement are not properly sanitized. Use a prepared statements
        (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using
        'connection.prepareStatement'.

         53â”† statement.execute( lock );


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/image/gif/GifDecoder.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.owasp.java.ssrf.java.net.url
        A parameter being passed directly into java.net.URL function most likely lead to SSRF.

        329â”† public int read(String name) {
        330â”†   status = STATUS_OK;
        331â”†   try {
        332â”†     name = name.trim();
        333â”†     if ((name.indexOf("file:") >= 0) ||
        334â”†       (name.indexOf(":/") > 0)) {
        335â”†       URL url = new URL(name);
        336â”†       in = new BufferedInputStream(url.openStream());
        337â”†     } else {
        338â”†       in = new BufferedInputStream(new FileInputStream(name));
           [hid 8 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/portlets/browser/ajax/BrowserAjax.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.httpservlet-path-traversal
        Detected a potential path traversal. A malicious actor could control the location of this
        file, to include going backwards in the directory with '../'. To address this, ensure that
        user-controlled variables in file paths are sanitized. You may also consider using a utility
        method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file
        name from the path.

        806â”† java.io.File file = fileAsset.getFileAsset();


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/portlets/calendar/ajax/CalendarAjax.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.httpservlet-path-traversal
        Detected a potential path traversal. A malicious actor could control the location of this
        file, to include going backwards in the directory with '../'. To address this, ensure that
        user-controlled variables in file paths are sanitized. You may also consider using a utility
        method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file
        name from the path.

        556â”† File binaryFile = new File(APILocator.getFileAssetAPI().getRealAssetPathTmpBinary()
        557â”† 		+ File.separator + user.getUserId() + File.separator + elementName
        558â”† 		+ File.separator + binaryFileValue);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/portlets/calendar/cms/struts/EventForm.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.httpservlet-path-traversal
        Detected a potential path traversal. A malicious actor could control the location of this
        file, to include going backwards in the directory with '../'. To address this, ensure that
        user-controlled variables in file paths are sanitized. You may also consider using a utility
        method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file
        name from the path.

        196â”† java.io.File image = uploadReq.getFile("image");


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/portlets/contentlet/ajax/ContentletAjax.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.httpservlet-path-traversal
        Detected a potential path traversal. A malicious actor could control the location of this
        file, to include going backwards in the directory with '../'. To address this, ensure that
        user-controlled variables in file paths are sanitized. You may also consider using a utility
        method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file
        name from the path.

       1776â”† File binaryFile = null;
          â‹®â”†----------------------------------------
       1787â”† binaryFile = new File(APILocator.getFileAssetAPI().getRealAssetPathTmpBinary()
       1788â”† 		+ File.separator + user.getUserId() + File.separator + "binary1"
       1789â”† 		+ File.separator + ((File)elementValue).getName());
          â‹®â”†----------------------------------------
       1795â”† binaryFile = new File(APILocator.getFileAssetAPI().getRealAssetPathTmpBinary()
       1796â”† 		+ File.separator + user.getUserId() + File.separator + elementName
       1797â”† 		+ File.separator + binaryFileValue);
          â‹®â”†----------------------------------------
       1803â”† File acopyFolder=new File(APILocator.getFileAssetAPI().getRealAssetPathTmpBinary()
       1804â”†         + File.separator + user.getUserId() + File.separator + elementName
       1805â”†         + File.separator + UUIDGenerator.generateUuid());
          â‹®â”†----------------------------------------
       1808â”† File acopy=new File(acopyFolder, binaryFileValue);
          â‹®â”†----------------------------------------
       2005â”† File tmp=new File(APILocator.getFileAssetAPI().getRealAssetPathTmpBinary()
       2006â”†         +File.separator+user.getUserId()+File.separator+ff.getFieldContentlet());


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/portlets/fileassets/ajax/FileAssetAjax.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.httpservlet-path-traversal
        Detected a potential path traversal. A malicious actor could control the location of this
        file, to include going backwards in the directory with '../'. To address this, ensure that
        user-controlled variables in file paths are sanitized. You may also consider using a utility
        method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file
        name from the path.

         48â”† java.io.File fileIO = fa.getFileAsset();
          â‹®â”†----------------------------------------
         94â”† final File fileData = new File(tempDir.getAbsoluteFile() + File.separator + WebKeys.TEMP_FILE_PREFIX + incomingFileName);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/portlets/osgi/AJAX/OSGIAJAX.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.httpservlet-path-traversal
        Detected a potential path traversal. A malicious actor could control the location of this
        file, to include going backwards in the directory with '../'. To address this, ensure that
        user-controlled variables in file paths are sanitized. You may also consider using a utility
        method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file
        name from the path.

         64â”† File from = new File(loadPath + File.separator + jarName);
          â‹®â”†----------------------------------------
         65â”† File to = new File(undeployedPath + File.separator + jarName);
          â‹®â”†----------------------------------------
         91â”† File from = new File(undeployedPath + File.separator + jarName);
          â‹®â”†----------------------------------------
         92â”† File to = new File(loadPath + File.separator + jarName);
          â‹®â”†----------------------------------------
        179â”† File osgiJar = new File(felixDeployFolder + File.separator + fileName);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/portlets/workflows/actionlet/VelocityScriptActionlet.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.script-engine-injection
        Detected potential code injection using ScriptEngine. Ensure user-controlled data cannot
        enter '.eval()', otherwise, this is a code injection vulnerability.

         88â”† @Override
         89â”† public void executeAction(final WorkflowProcessor processor,
         90â”†                           final Map<String, WorkflowActionClassParameter> params) throws WorkflowActionFailureException {
         91â”† 
         92â”†     try {
         93â”†         final User  currentUser          = processor.getUser();
         94â”†         final HttpServletRequest request =
         95â”†                 null == HttpServletRequestThreadLocal.INSTANCE.getRequest()?
         96â”†                         this.mockRequest(currentUser): HttpServletRequestThreadLocal.INSTANCE.getRequest();
         97â”†         final HttpServletResponse response =
           [hid 24 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/servlets/BinaryExporterServlet.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.httpservlet-path-traversal
        Detected a potential path traversal. A malicious actor could control the location of this
        file, to include going backwards in the directory with '../'. To address this, ensure that
        user-controlled variables in file paths are sanitized. You may also consider using a utility
        method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file
        name from the path.

        356â”† inputFile = contentAPI.getBinaryFile(content.getInode(), field.variable(), APILocator.getUserAPI().getSystemUser());
          â‹®â”†----------------------------------------
        358â”† inputFile = contentAPI.getBinaryFile(content.getInode(), field.variable(), user);
          â‹®â”†----------------------------------------
        382â”† inputFile = tempFileAPI.getTempFile(req, shorty.longId).get().file;


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/util/RuntimeUtils.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.command-injection-process-builder
        A formatted or concatenated string was detected as input to a ProcessBuilder call. This is
        dangerous if a variable is controlled by user input and could result in a command injection.
        Ensure your variables are not controlled by users or sufficiently sanitized.

        136â”† return new ProcessBuilder(commands).redirectErrorStream(true);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/dotmarketing/util/XMLUtils.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.documentbuilderfactory-disallow-
     doctype-decl-missing
        DOCTYPE declarations are enabled for this DocumentBuilderFactory. This is vulnerable to XML
        external entity attacks. Disable this by setting the feature
        "http://apache.org/xml/features/disallow-doctype-decl" to true. Alternatively, allow DOCTYPE
        declarations and only prohibit external entities declarations. This can be done by setting
        the features "http://xml.org/sax/features/external-general-entities" and
        "http://xml.org/sax/features/external-parameter-entities" to false.

         â–¶â–¶â”† Autofix â–¶ factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
factory.newDocumentBuilder();
         88â”† final DocumentBuilder documentBuilder = factory.newDocumentBuilder();


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/liferay/portlet/PortletPreferencesSerializer.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.owasp.java.xxe.org.dom4j.io.SAXReader
        SAXReader being instantiated without calling the setFeature functions that are generally
        used for disabling entity processing

         73â”† SAXReader xmlReader = new SAXReader();
          â‹®â”†----------------------------------------
         73â”† SAXReader xmlReader = new SAXReader();
         74â”† xmlReader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
         75â”† 
         76â”† Document doc = xmlReader.read(new StringReader(xml));


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/com/liferay/util/Base64.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.object-deserialization
        Found object deserialization using ObjectInputStream. Deserializing entire Java objects is
        dangerous because malicious actors can create Java object streams with unintended
        consequences. Ensure that the objects being deserialized are not user-controlled. If this
        must be done, consider using HMACs to sign the data stream to make sure it is not tampered
        with, or consider only transmitting object fields and populating a new object.

        186â”† ObjectInputStream is =
        187â”† 	new ObjectInputStream(new BufferedInputStream(baos));


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/org/apache/velocity/tools/view/ImportSupport.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.owasp.java.ssrf.java.net.url
        A parameter being passed directly into java.net.URL function most likely lead to SSRF.

        173â”† protected Reader acquireReader(final String url, final long timeout, Map<String, String> headers) throws IOException, Exception
        174â”† {
        175â”†     if (!this.isAbsoluteUrl)
        176â”†     {
        177â”†         // for relative URLs, delegate to our peer
        178â”†         return new StringReader(acquireString(url, timeout, headers));
        179â”†     }
        180â”†     else
        181â”†     {
        182â”†         // absolute URL
           [hid 79 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/org/apache/velocity/tools/view/XMLToolboxManager.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.owasp.java.xxe.org.apache.commons.diges
     ter3.Digester
        Digester being instantiated without calling the setFeature functions that are generally used
        for disabling entity processing

        204â”† Digester digester = new Digester();
        205â”† digester.setValidating(false);
        206â”† digester.setUseContextClassLoader(true);
        207â”† digester.push(this);
        208â”† digester.addRuleSet(getRuleSet());
        209â”† digester.parse(input);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/dotCMS/src/main/java/org/quartz/impl/jdbcjobstore/DotMSSQLDelegate.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.object-deserialization
        Found object deserialization using ObjectInputStream. Deserializing entire Java objects is
        dangerous because malicious actors can create Java object streams with unintended
        consequences. Ensure that the objects being deserialized are not user-controlled. If this
        must be done, consider using HMACs to sign the data stream to make sure it is not tampered
        with, or consider only transmitting object fields and populating a new object.

         30â”† in= new ObjectInputStream(binaryInput);


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/dotCMS.core/tools/dotcms-cli/.mvn/wrapper/MavenWrapperDownloader.java 
     home.rtz.github_vuln_research.my_semgrep_rules.java_semgrep_rules.owasp.java.ssrf.java.net.url
        A parameter being passed directly into java.net.URL function most likely lead to SSRF.

        117â”† private static void downloadFileFromURL( String urlString, File destination )
        118â”†     throws Exception
        119â”† {
        120â”†     if ( System.getenv( "MVNW_USERNAME" ) != null && System.getenv( "MVNW_PASSWORD" ) != null )
        121â”†     {
        122â”†         String username = System.getenv( "MVNW_USERNAME" );
        123â”†         char[] password = System.getenv( "MVNW_PASSWORD" ).toCharArray();
        124â”†         Authenticator.setDefault( new Authenticator()
        125â”†         {
        126â”†             @Override
           [hid 14 additional lines, adjust with --max-lines-per-finding] 
